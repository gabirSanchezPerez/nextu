"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var filter_1 = require("./filter");
var takeLast_1 = require("./takeLast");
var throwIfEmpty_1 = require("./throwIfEmpty");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var identity_1 = require("../util/identity");
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * ![](last.png)
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} [predicate] - The condition any source emitted item has to satisfy.
 * @param {any} [defaultValue] - An optional default value to provide if last
 * predicate isn't met or no values were emitted.
 * @return {Observable} An Observable that emits only the last item satisfying the given condition
 * from the source, or an NoSuchElementException if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 */
function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.last = last;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFHQSxpREFBZ0Q7QUFFaEQsbUNBQWtDO0FBQ2xDLHVDQUFzQztBQUN0QywrQ0FBOEM7QUFDOUMsbURBQWtEO0FBQ2xELDZDQUE0QztBQWU1QyxtQ0FBbUM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxTQUFnQixJQUFJLENBQ2xCLFNBQWdGLEVBQ2hGLFlBQWdCO0lBRWhCLElBQU0sZUFBZSxHQUFHLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDO0lBQzlDLE9BQU8sVUFBQyxNQUFxQixJQUFLLE9BQUEsTUFBTSxDQUFDLElBQUksQ0FDM0MsU0FBUyxDQUFDLENBQUMsQ0FBQyxlQUFNLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxJQUFLLE9BQUEsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQXZCLENBQXVCLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQVEsRUFDaEUsbUJBQVEsQ0FBQyxDQUFDLENBQUMsRUFDWCxlQUFlLENBQUMsQ0FBQyxDQUFDLCtCQUFjLENBQVEsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLDJCQUFZLENBQUMsY0FBTSxPQUFBLElBQUksdUJBQVUsRUFBRSxFQUFoQixDQUFnQixDQUFDLENBQzdGLEVBSmlDLENBSWpDLENBQUM7QUFDSixDQUFDO0FBVkQsb0JBVUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IEVtcHR5RXJyb3IgfSBmcm9tICcuLi91dGlsL0VtcHR5RXJyb3InO1xuaW1wb3J0IHsgT3BlcmF0b3JGdW5jdGlvbiB9IGZyb20gJy4uLy4uL2ludGVybmFsL3R5cGVzJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCB7IHRha2VMYXN0IH0gZnJvbSAnLi90YWtlTGFzdCc7XG5pbXBvcnQgeyB0aHJvd0lmRW1wdHkgfSBmcm9tICcuL3Rocm93SWZFbXB0eSc7XG5pbXBvcnQgeyBkZWZhdWx0SWZFbXB0eSB9IGZyb20gJy4vZGVmYXVsdElmRW1wdHknO1xuaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICcuLi91dGlsL2lkZW50aXR5JztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gbGFzdDxULCBEID0gVD4oXG4gIHByZWRpY2F0ZT86IG51bGwsXG4gIGRlZmF1bHRWYWx1ZT86IERcbik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVCB8IEQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCwgUyBleHRlbmRzIFQ+KFxuICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiB2YWx1ZSBpcyBTLFxuICBkZWZhdWx0VmFsdWU/OiBTXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFM+O1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCwgRCA9IFQ+KFxuICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICBkZWZhdWx0VmFsdWU/OiBEXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBEPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgbGFzdCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogSXQgb3B0aW9uYWxseSB0YWtlcyBhIHByZWRpY2F0ZSBmdW5jdGlvbiBhcyBhIHBhcmFtZXRlciwgaW4gd2hpY2ggY2FzZSwgcmF0aGVyIHRoYW4gZW1pdHRpbmdcbiAqIHRoZSBsYXN0IGl0ZW0gZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZSByZXN1bHRpbmcgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgdGhlIGxhc3QgaXRlbVxuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZS5cbiAqXG4gKiAhW10obGFzdC5wbmcpXG4gKlxuICogQHRocm93cyB7RW1wdHlFcnJvcn0gRGVsaXZlcnMgYW4gRW1wdHlFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgXG4gKiBjYWxsYmFjayBpZiB0aGUgT2JzZXJ2YWJsZSBjb21wbGV0ZXMgYmVmb3JlIGFueSBgbmV4dGAgbm90aWZpY2F0aW9uIHdhcyBzZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3ByZWRpY2F0ZV0gLSBUaGUgY29uZGl0aW9uIGFueSBzb3VyY2UgZW1pdHRlZCBpdGVtIGhhcyB0byBzYXRpc2Z5LlxuICogQHBhcmFtIHthbnl9IFtkZWZhdWx0VmFsdWVdIC0gQW4gb3B0aW9uYWwgZGVmYXVsdCB2YWx1ZSB0byBwcm92aWRlIGlmIGxhc3RcbiAqIHByZWRpY2F0ZSBpc24ndCBtZXQgb3Igbm8gdmFsdWVzIHdlcmUgZW1pdHRlZC5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBsYXN0IGl0ZW0gc2F0aXNmeWluZyB0aGUgZ2l2ZW4gY29uZGl0aW9uXG4gKiBmcm9tIHRoZSBzb3VyY2UsIG9yIGFuIE5vU3VjaEVsZW1lbnRFeGNlcHRpb24gaWYgbm8gc3VjaCBpdGVtcyBhcmUgZW1pdHRlZC5cbiAqIEB0aHJvd3MgLSBUaHJvd3MgaWYgbm8gaXRlbXMgdGhhdCBtYXRjaCB0aGUgcHJlZGljYXRlIGFyZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCwgRD4oXG4gIHByZWRpY2F0ZT86ICgodmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gYm9vbGVhbikgfCBudWxsLFxuICBkZWZhdWx0VmFsdWU/OiBEXG4pOiBPcGVyYXRvckZ1bmN0aW9uPFQsIFQgfCBEPiB7XG4gIGNvbnN0IGhhc0RlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMjtcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHNvdXJjZS5waXBlKFxuICAgIHByZWRpY2F0ZSA/IGZpbHRlcigodiwgaSkgPT4gcHJlZGljYXRlKHYsIGksIHNvdXJjZSkpIDogaWRlbnRpdHksXG4gICAgdGFrZUxhc3QoMSksXG4gICAgaGFzRGVmYXVsdFZhbHVlID8gZGVmYXVsdElmRW1wdHk8VCB8IEQ+KGRlZmF1bHRWYWx1ZSkgOiB0aHJvd0lmRW1wdHkoKCkgPT4gbmV3IEVtcHR5RXJyb3IoKSksXG4gICk7XG59XG4iXX0=