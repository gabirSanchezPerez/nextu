"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var isFunction_1 = require("../util/isFunction");
var map_1 = require("../operators/map");
var toString = Object.prototype.toString;
/* tslint:enable:max-line-length */
/**
 * Creates an Observable that emits events of a specific type coming from the
 * given event target.
 *
 * <span class="informal">Creates an Observable from DOM events, or Node.js
 * EventEmitter events or others.</span>
 *
 * ![](fromEvent.png)
 *
 * `fromEvent` accepts as a first argument event target, which is an object with methods
 * for registering event handler functions. As a second argument it takes string that indicates
 * type of event we want to listen for. `fromEvent` supports selected types of event targets,
 * which are described in detail below. If your event target does not match any of the ones listed,
 * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
 * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
 * handler functions have different names, but they all accept a string describing event type
 * and function itself, which will be called whenever said event happens.
 *
 * Every time resulting Observable is subscribed, event handler function will be registered
 * to event target on given event type. When that event fires, value
 * passed as a first argument to registered function will be emitted by output Observable.
 * When Observable is unsubscribed, function will be unregistered from event target.
 *
 * Note that if event target calls registered function with more than one argument, second
 * and following arguments will not appear in resulting stream. In order to get access to them,
 * you can pass to `fromEvent` optional project function, which will be called with all arguments
 * passed to event handler. Output Observable will then emit value returned by project function,
 * instead of the usual value.
 *
 * Remember that event targets listed below are checked via duck typing. It means that
 * no matter what kind of object you have and no matter what environment you work in,
 * you can safely use `fromEvent` on that object if it exposes described methods (provided
 * of course they behave as was described above). So for example if Node.js library exposes
 * event target which has the same method names as DOM EventTarget, `fromEvent` is still
 * a good choice.
 *
 * If the API you use is more callback then event handler oriented (subscribed
 * callback function fires only once and thus there is no need to manually
 * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
 * instead.
 *
 * `fromEvent` supports following types of event targets:
 *
 * **DOM EventTarget**
 *
 * This is an object with `addEventListener` and `removeEventListener` methods.
 *
 * In the browser, `addEventListener` accepts - apart from event type string and event
 * handler function arguments - optional third parameter, which is either an object or boolean,
 * both used for additional configuration how and when passed function will be called. When
 * `fromEvent` is used with event target of that type, you can provide this values
 * as third parameter as well.
 *
 * **Node.js EventEmitter**
 *
 * An object with `addListener` and `removeListener` methods.
 *
 * **JQuery-style event target**
 *
 * An object with `on` and `off` methods
 *
 * **DOM NodeList**
 *
 * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
 *
 * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
 * it contains and install event handler function in every of them. When returned Observable
 * is unsubscribed, function will be removed from all Nodes.
 *
 * **DOM HtmlCollection**
 *
 * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
 * installed and removed in each of elements.
 *
 *
 * ## Examples
 * ### Emits clicks happening on the DOM document
 * ```javascript
 * const clicks = fromEvent(document, 'click');
 * clicks.subscribe(x => console.log(x));
 *
 * // Results in:
 * // MouseEvent object logged to console every time a click
 * // occurs on the document.
 * ```
 *
 * ### Use addEventListener with capture option
 * ```javascript
 * const clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter
 *                                                              // which will be passed to addEventListener
 * const clicksInDiv = fromEvent(someDivInDocument, 'click');
 *
 * clicksInDocument.subscribe(() => console.log('document'));
 * clicksInDiv.subscribe(() => console.log('div'));
 *
 * // By default events bubble UP in DOM tree, so normally
 * // when we would click on div in document
 * // "div" would be logged first and then "document".
 * // Since we specified optional `capture` option, document
 * // will catch event when it goes DOWN DOM tree, so console
 * // will log "document" and then "div".
 * ```
 *
 * @see {@link bindCallback}
 * @see {@link bindNodeCallback}
 * @see {@link fromEventPattern}
 *
 * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js
 * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
 * @param {string} eventName The event name of interest, being emitted by the
 * `target`.
 * @param {EventListenerOptions} [options] Options to pass through to addEventListener
 * @return {Observable<T>}
 * @name fromEvent
 */
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
        // DEPRECATED PATH
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        // DEPRECATED PATH
        return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
exports.fromEvent = fromEvent;
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJvbUV2ZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZnJvbUV2ZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsNENBQTJDO0FBQzNDLDJDQUEwQztBQUMxQyxpREFBZ0Q7QUFFaEQsd0NBQXVDO0FBRXZDLElBQU0sUUFBUSxHQUFhLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO0FBaURyRCxtQ0FBbUM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtIRztBQUNILFNBQWdCLFNBQVMsQ0FDdkIsTUFBMEIsRUFDMUIsU0FBaUIsRUFDakIsT0FBd0QsRUFDeEQsY0FBd0M7SUFHeEMsSUFBSSx1QkFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ3ZCLGtCQUFrQjtRQUNsQixjQUFjLEdBQUcsT0FBTyxDQUFDO1FBQ3pCLE9BQU8sR0FBRyxTQUFTLENBQUM7S0FDckI7SUFDRCxJQUFJLGNBQWMsRUFBRTtRQUNsQixrQkFBa0I7UUFDbEIsT0FBTyxTQUFTLENBQUksTUFBTSxFQUFFLFNBQVMsRUFBb0MsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUNwRixTQUFHLENBQUMsVUFBQSxJQUFJLElBQUksT0FBQSxpQkFBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLGVBQUksSUFBSSxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQTlELENBQThELENBQUMsQ0FDNUUsQ0FBQztLQUNIO0lBRUQsT0FBTyxJQUFJLHVCQUFVLENBQUksVUFBQSxVQUFVO1FBQ2pDLFNBQVMsT0FBTyxDQUFDLENBQUk7WUFDbkIsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDeEIsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQzthQUN4RDtpQkFBTTtnQkFDTCxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3BCO1FBQ0gsQ0FBQztRQUNELGlCQUFpQixDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUErQixDQUFDLENBQUM7SUFDN0YsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBN0JELDhCQTZCQztBQUVELFNBQVMsaUJBQWlCLENBQUksU0FBNkIsRUFBRSxTQUFpQixFQUNoRCxPQUFpQyxFQUFFLFVBQXlCLEVBQzVELE9BQThCO0lBQzFELElBQUksV0FBdUIsQ0FBQztJQUM1QixJQUFJLGFBQWEsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUM1QixJQUFNLFFBQU0sR0FBRyxTQUFTLENBQUM7UUFDekIsU0FBUyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDeEQsV0FBVyxHQUFHLGNBQU0sT0FBQSxRQUFNLENBQUMsbUJBQW1CLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBdkQsQ0FBdUQsQ0FBQztLQUM3RTtTQUFNLElBQUkseUJBQXlCLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDL0MsSUFBTSxRQUFNLEdBQUcsU0FBUyxDQUFDO1FBQ3pCLFNBQVMsQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2pDLFdBQVcsR0FBRyxjQUFNLE9BQUEsUUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLEVBQTlCLENBQThCLENBQUM7S0FDcEQ7U0FBTSxJQUFJLHVCQUF1QixDQUFDLFNBQVMsQ0FBQyxFQUFFO1FBQzdDLElBQU0sUUFBTSxHQUFHLFNBQVMsQ0FBQztRQUN6QixTQUFTLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxPQUEyQixDQUFDLENBQUM7UUFDOUQsV0FBVyxHQUFHLGNBQU0sT0FBQSxRQUFNLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFBRSxPQUEyQixDQUFDLEVBQTdELENBQTZELENBQUM7S0FDbkY7U0FBTSxJQUFJLFNBQVMsSUFBSyxTQUFpQixDQUFDLE1BQU0sRUFBRTtRQUNqRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUksU0FBaUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM3RCxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDMUU7S0FDRjtTQUFNO1FBQ0wsTUFBTSxJQUFJLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0tBQzdDO0lBRUQsVUFBVSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUM5QixDQUFDO0FBRUQsU0FBUyx1QkFBdUIsQ0FBQyxTQUFjO0lBQzdDLE9BQU8sU0FBUyxJQUFJLE9BQU8sU0FBUyxDQUFDLFdBQVcsS0FBSyxVQUFVLElBQUksT0FBTyxTQUFTLENBQUMsY0FBYyxLQUFLLFVBQVUsQ0FBQztBQUNwSCxDQUFDO0FBRUQsU0FBUyx5QkFBeUIsQ0FBQyxTQUFjO0lBQy9DLE9BQU8sU0FBUyxJQUFJLE9BQU8sU0FBUyxDQUFDLEVBQUUsS0FBSyxVQUFVLElBQUksT0FBTyxTQUFTLENBQUMsR0FBRyxLQUFLLFVBQVUsQ0FBQztBQUNoRyxDQUFDO0FBRUQsU0FBUyxhQUFhLENBQUMsU0FBYztJQUNuQyxPQUFPLFNBQVMsSUFBSSxPQUFPLFNBQVMsQ0FBQyxnQkFBZ0IsS0FBSyxVQUFVLElBQUksT0FBTyxTQUFTLENBQUMsbUJBQW1CLEtBQUssVUFBVSxDQUFDO0FBQzlILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5JztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vb3BlcmF0b3JzL21hcCc7XG5cbmNvbnN0IHRvU3RyaW5nOiBGdW5jdGlvbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9kZVN0eWxlRXZlbnRFbWl0dGVyIHtcbiAgYWRkTGlzdGVuZXI6IChldmVudE5hbWU6IHN0cmluZyB8IHN5bWJvbCwgaGFuZGxlcjogTm9kZUV2ZW50SGFuZGxlcikgPT4gdGhpcztcbiAgcmVtb3ZlTGlzdGVuZXI6IChldmVudE5hbWU6IHN0cmluZyB8IHN5bWJvbCwgaGFuZGxlcjogTm9kZUV2ZW50SGFuZGxlcikgPT4gdGhpcztcbn1cblxuZXhwb3J0IHR5cGUgTm9kZUV2ZW50SGFuZGxlciA9ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcblxuLy8gRm9yIEFQSXMgdGhhdCBpbXBsZW1lbnQgYGFkZExpc3RlbmVyYCBhbmQgYHJlbW92ZUxpc3RlbmVyYCBtZXRob2RzIHRoYXQgbWF5XG4vLyBub3QgdXNlIHRoZSBzYW1lIGFyZ3VtZW50cyBvciByZXR1cm4gRXZlbnRFbWl0dGVyIHZhbHVlc1xuLy8gc3VjaCBhcyBSZWFjdCBOYXRpdmVcbmV4cG9ydCBpbnRlcmZhY2UgTm9kZUNvbXBhdGlibGVFdmVudEVtaXR0ZXIge1xuICBhZGRMaXN0ZW5lcjogKGV2ZW50TmFtZTogc3RyaW5nLCBoYW5kbGVyOiBOb2RlRXZlbnRIYW5kbGVyKSA9PiB2b2lkIHwge307XG4gIHJlbW92ZUxpc3RlbmVyOiAoZXZlbnROYW1lOiBzdHJpbmcsIGhhbmRsZXI6IE5vZGVFdmVudEhhbmRsZXIpID0+IHZvaWQgfCB7fTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKUXVlcnlTdHlsZUV2ZW50RW1pdHRlciB7XG4gIG9uOiAoZXZlbnROYW1lOiBzdHJpbmcsIGhhbmRsZXI6IEZ1bmN0aW9uKSA9PiB2b2lkO1xuICBvZmY6IChldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFzRXZlbnRUYXJnZXRBZGRSZW1vdmU8RT4ge1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGU6IHN0cmluZywgbGlzdGVuZXI6ICgoZXZ0OiBFKSA9PiB2b2lkKSB8IG51bGwsIG9wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpOiB2b2lkO1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGU6IHN0cmluZywgbGlzdGVuZXI/OiAoKGV2dDogRSkgPT4gdm9pZCkgfCBudWxsLCBvcHRpb25zPzogRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCBib29sZWFuKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgRXZlbnRUYXJnZXRMaWtlPFQ+ID0gSGFzRXZlbnRUYXJnZXRBZGRSZW1vdmU8VD4gfCBOb2RlU3R5bGVFdmVudEVtaXR0ZXIgfCBOb2RlQ29tcGF0aWJsZUV2ZW50RW1pdHRlciB8IEpRdWVyeVN0eWxlRXZlbnRFbWl0dGVyO1xuXG5leHBvcnQgdHlwZSBGcm9tRXZlbnRUYXJnZXQ8VD4gPSBFdmVudFRhcmdldExpa2U8VD4gfCBBcnJheUxpa2U8RXZlbnRUYXJnZXRMaWtlPFQ+PjtcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudExpc3RlbmVyT3B0aW9ucyB7XG4gIGNhcHR1cmU/OiBib29sZWFuO1xuICBwYXNzaXZlPzogYm9vbGVhbjtcbiAgb25jZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgZXh0ZW5kcyBFdmVudExpc3RlbmVyT3B0aW9ucyB7XG4gIG9uY2U/OiBib29sZWFuO1xuICBwYXNzaXZlPzogYm9vbGVhbjtcbn1cblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV2ZW50PFQ+KHRhcmdldDogRnJvbUV2ZW50VGFyZ2V0PFQ+LCBldmVudE5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8VD47XG4vKiogQGRlcHJlY2F0ZWQgcmVzdWx0U2VsZWN0b3Igbm8gbG9uZ2VyIHN1cHBvcnRlZCwgcGlwZSB0byBtYXAgaW5zdGVhZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdmVudDxUPih0YXJnZXQ6IEZyb21FdmVudFRhcmdldDxUPiwgZXZlbnROYW1lOiBzdHJpbmcsIHJlc3VsdFNlbGVjdG9yOiAoLi4uYXJnczogYW55W10pID0+IFQpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdmVudDxUPih0YXJnZXQ6IEZyb21FdmVudFRhcmdldDxUPiwgZXZlbnROYW1lOiBzdHJpbmcsIG9wdGlvbnM6IEV2ZW50TGlzdGVuZXJPcHRpb25zKTogT2JzZXJ2YWJsZTxUPjtcbi8qKiBAZGVwcmVjYXRlZCByZXN1bHRTZWxlY3RvciBubyBsb25nZXIgc3VwcG9ydGVkLCBwaXBlIHRvIG1hcCBpbnN0ZWFkICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV2ZW50PFQ+KHRhcmdldDogRnJvbUV2ZW50VGFyZ2V0PFQ+LCBldmVudE5hbWU6IHN0cmluZywgb3B0aW9uczogRXZlbnRMaXN0ZW5lck9wdGlvbnMsIHJlc3VsdFNlbGVjdG9yOiAoLi4uYXJnczogYW55W10pID0+IFQpOiBPYnNlcnZhYmxlPFQ+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBldmVudHMgb2YgYSBzcGVjaWZpYyB0eXBlIGNvbWluZyBmcm9tIHRoZVxuICogZ2l2ZW4gZXZlbnQgdGFyZ2V0LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIGFuIE9ic2VydmFibGUgZnJvbSBET00gZXZlbnRzLCBvciBOb2RlLmpzXG4gKiBFdmVudEVtaXR0ZXIgZXZlbnRzIG9yIG90aGVycy48L3NwYW4+XG4gKlxuICogIVtdKGZyb21FdmVudC5wbmcpXG4gKlxuICogYGZyb21FdmVudGAgYWNjZXB0cyBhcyBhIGZpcnN0IGFyZ3VtZW50IGV2ZW50IHRhcmdldCwgd2hpY2ggaXMgYW4gb2JqZWN0IHdpdGggbWV0aG9kc1xuICogZm9yIHJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zLiBBcyBhIHNlY29uZCBhcmd1bWVudCBpdCB0YWtlcyBzdHJpbmcgdGhhdCBpbmRpY2F0ZXNcbiAqIHR5cGUgb2YgZXZlbnQgd2Ugd2FudCB0byBsaXN0ZW4gZm9yLiBgZnJvbUV2ZW50YCBzdXBwb3J0cyBzZWxlY3RlZCB0eXBlcyBvZiBldmVudCB0YXJnZXRzLFxuICogd2hpY2ggYXJlIGRlc2NyaWJlZCBpbiBkZXRhaWwgYmVsb3cuIElmIHlvdXIgZXZlbnQgdGFyZ2V0IGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgb25lcyBsaXN0ZWQsXG4gKiB5b3Ugc2hvdWxkIHVzZSB7QGxpbmsgZnJvbUV2ZW50UGF0dGVybn0sIHdoaWNoIGNhbiBiZSB1c2VkIG9uIGFyYml0cmFyeSBBUElzLlxuICogV2hlbiBpdCBjb21lcyB0byBBUElzIHN1cHBvcnRlZCBieSBgZnJvbUV2ZW50YCwgdGhlaXIgbWV0aG9kcyBmb3IgYWRkaW5nIGFuZCByZW1vdmluZyBldmVudFxuICogaGFuZGxlciBmdW5jdGlvbnMgaGF2ZSBkaWZmZXJlbnQgbmFtZXMsIGJ1dCB0aGV5IGFsbCBhY2NlcHQgYSBzdHJpbmcgZGVzY3JpYmluZyBldmVudCB0eXBlXG4gKiBhbmQgZnVuY3Rpb24gaXRzZWxmLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBzYWlkIGV2ZW50IGhhcHBlbnMuXG4gKlxuICogRXZlcnkgdGltZSByZXN1bHRpbmcgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLCBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIHdpbGwgYmUgcmVnaXN0ZXJlZFxuICogdG8gZXZlbnQgdGFyZ2V0IG9uIGdpdmVuIGV2ZW50IHR5cGUuIFdoZW4gdGhhdCBldmVudCBmaXJlcywgdmFsdWVcbiAqIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50IHRvIHJlZ2lzdGVyZWQgZnVuY3Rpb24gd2lsbCBiZSBlbWl0dGVkIGJ5IG91dHB1dCBPYnNlcnZhYmxlLlxuICogV2hlbiBPYnNlcnZhYmxlIGlzIHVuc3Vic2NyaWJlZCwgZnVuY3Rpb24gd2lsbCBiZSB1bnJlZ2lzdGVyZWQgZnJvbSBldmVudCB0YXJnZXQuXG4gKlxuICogTm90ZSB0aGF0IGlmIGV2ZW50IHRhcmdldCBjYWxscyByZWdpc3RlcmVkIGZ1bmN0aW9uIHdpdGggbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgc2Vjb25kXG4gKiBhbmQgZm9sbG93aW5nIGFyZ3VtZW50cyB3aWxsIG5vdCBhcHBlYXIgaW4gcmVzdWx0aW5nIHN0cmVhbS4gSW4gb3JkZXIgdG8gZ2V0IGFjY2VzcyB0byB0aGVtLFxuICogeW91IGNhbiBwYXNzIHRvIGBmcm9tRXZlbnRgIG9wdGlvbmFsIHByb2plY3QgZnVuY3Rpb24sIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIGFyZ3VtZW50c1xuICogcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXIuIE91dHB1dCBPYnNlcnZhYmxlIHdpbGwgdGhlbiBlbWl0IHZhbHVlIHJldHVybmVkIGJ5IHByb2plY3QgZnVuY3Rpb24sXG4gKiBpbnN0ZWFkIG9mIHRoZSB1c3VhbCB2YWx1ZS5cbiAqXG4gKiBSZW1lbWJlciB0aGF0IGV2ZW50IHRhcmdldHMgbGlzdGVkIGJlbG93IGFyZSBjaGVja2VkIHZpYSBkdWNrIHR5cGluZy4gSXQgbWVhbnMgdGhhdFxuICogbm8gbWF0dGVyIHdoYXQga2luZCBvZiBvYmplY3QgeW91IGhhdmUgYW5kIG5vIG1hdHRlciB3aGF0IGVudmlyb25tZW50IHlvdSB3b3JrIGluLFxuICogeW91IGNhbiBzYWZlbHkgdXNlIGBmcm9tRXZlbnRgIG9uIHRoYXQgb2JqZWN0IGlmIGl0IGV4cG9zZXMgZGVzY3JpYmVkIG1ldGhvZHMgKHByb3ZpZGVkXG4gKiBvZiBjb3Vyc2UgdGhleSBiZWhhdmUgYXMgd2FzIGRlc2NyaWJlZCBhYm92ZSkuIFNvIGZvciBleGFtcGxlIGlmIE5vZGUuanMgbGlicmFyeSBleHBvc2VzXG4gKiBldmVudCB0YXJnZXQgd2hpY2ggaGFzIHRoZSBzYW1lIG1ldGhvZCBuYW1lcyBhcyBET00gRXZlbnRUYXJnZXQsIGBmcm9tRXZlbnRgIGlzIHN0aWxsXG4gKiBhIGdvb2QgY2hvaWNlLlxuICpcbiAqIElmIHRoZSBBUEkgeW91IHVzZSBpcyBtb3JlIGNhbGxiYWNrIHRoZW4gZXZlbnQgaGFuZGxlciBvcmllbnRlZCAoc3Vic2NyaWJlZFxuICogY2FsbGJhY2sgZnVuY3Rpb24gZmlyZXMgb25seSBvbmNlIGFuZCB0aHVzIHRoZXJlIGlzIG5vIG5lZWQgdG8gbWFudWFsbHlcbiAqIHVucmVnaXN0ZXIgaXQpLCB5b3Ugc2hvdWxkIHVzZSB7QGxpbmsgYmluZENhbGxiYWNrfSBvciB7QGxpbmsgYmluZE5vZGVDYWxsYmFja31cbiAqIGluc3RlYWQuXG4gKlxuICogYGZyb21FdmVudGAgc3VwcG9ydHMgZm9sbG93aW5nIHR5cGVzIG9mIGV2ZW50IHRhcmdldHM6XG4gKlxuICogKipET00gRXZlbnRUYXJnZXQqKlxuICpcbiAqIFRoaXMgaXMgYW4gb2JqZWN0IHdpdGggYGFkZEV2ZW50TGlzdGVuZXJgIGFuZCBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgbWV0aG9kcy5cbiAqXG4gKiBJbiB0aGUgYnJvd3NlciwgYGFkZEV2ZW50TGlzdGVuZXJgIGFjY2VwdHMgLSBhcGFydCBmcm9tIGV2ZW50IHR5cGUgc3RyaW5nIGFuZCBldmVudFxuICogaGFuZGxlciBmdW5jdGlvbiBhcmd1bWVudHMgLSBvcHRpb25hbCB0aGlyZCBwYXJhbWV0ZXIsIHdoaWNoIGlzIGVpdGhlciBhbiBvYmplY3Qgb3IgYm9vbGVhbixcbiAqIGJvdGggdXNlZCBmb3IgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIGhvdyBhbmQgd2hlbiBwYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQuIFdoZW5cbiAqIGBmcm9tRXZlbnRgIGlzIHVzZWQgd2l0aCBldmVudCB0YXJnZXQgb2YgdGhhdCB0eXBlLCB5b3UgY2FuIHByb3ZpZGUgdGhpcyB2YWx1ZXNcbiAqIGFzIHRoaXJkIHBhcmFtZXRlciBhcyB3ZWxsLlxuICpcbiAqICoqTm9kZS5qcyBFdmVudEVtaXR0ZXIqKlxuICpcbiAqIEFuIG9iamVjdCB3aXRoIGBhZGRMaXN0ZW5lcmAgYW5kIGByZW1vdmVMaXN0ZW5lcmAgbWV0aG9kcy5cbiAqXG4gKiAqKkpRdWVyeS1zdHlsZSBldmVudCB0YXJnZXQqKlxuICpcbiAqIEFuIG9iamVjdCB3aXRoIGBvbmAgYW5kIGBvZmZgIG1ldGhvZHNcbiAqXG4gKiAqKkRPTSBOb2RlTGlzdCoqXG4gKlxuICogTGlzdCBvZiBET00gTm9kZXMsIHJldHVybmVkIGZvciBleGFtcGxlIGJ5IGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsYCBvciBgTm9kZS5jaGlsZE5vZGVzYC5cbiAqXG4gKiBBbHRob3VnaCB0aGlzIGNvbGxlY3Rpb24gaXMgbm90IGV2ZW50IHRhcmdldCBpbiBpdHNlbGYsIGBmcm9tRXZlbnRgIHdpbGwgaXRlcmF0ZSBvdmVyIGFsbCBOb2Rlc1xuICogaXQgY29udGFpbnMgYW5kIGluc3RhbGwgZXZlbnQgaGFuZGxlciBmdW5jdGlvbiBpbiBldmVyeSBvZiB0aGVtLiBXaGVuIHJldHVybmVkIE9ic2VydmFibGVcbiAqIGlzIHVuc3Vic2NyaWJlZCwgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGZyb20gYWxsIE5vZGVzLlxuICpcbiAqICoqRE9NIEh0bWxDb2xsZWN0aW9uKipcbiAqXG4gKiBKdXN0IGFzIGluIGNhc2Ugb2YgTm9kZUxpc3QgaXQgaXMgYSBjb2xsZWN0aW9uIG9mIERPTSBub2Rlcy4gSGVyZSBhcyB3ZWxsIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gaXNcbiAqIGluc3RhbGxlZCBhbmQgcmVtb3ZlZCBpbiBlYWNoIG9mIGVsZW1lbnRzLlxuICpcbiAqXG4gKiAjIyBFeGFtcGxlc1xuICogIyMjIEVtaXRzIGNsaWNrcyBoYXBwZW5pbmcgb24gdGhlIERPTSBkb2N1bWVudFxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgY2xpY2tzID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIGNsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbjpcbiAqIC8vIE1vdXNlRXZlbnQgb2JqZWN0IGxvZ2dlZCB0byBjb25zb2xlIGV2ZXJ5IHRpbWUgYSBjbGlja1xuICogLy8gb2NjdXJzIG9uIHRoZSBkb2N1bWVudC5cbiAqIGBgYFxuICpcbiAqICMjIyBVc2UgYWRkRXZlbnRMaXN0ZW5lciB3aXRoIGNhcHR1cmUgb3B0aW9uXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBjbGlja3NJbkRvY3VtZW50ID0gZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snLCB0cnVlKTsgLy8gbm90ZSBvcHRpb25hbCBjb25maWd1cmF0aW9uIHBhcmFtZXRlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGFkZEV2ZW50TGlzdGVuZXJcbiAqIGNvbnN0IGNsaWNrc0luRGl2ID0gZnJvbUV2ZW50KHNvbWVEaXZJbkRvY3VtZW50LCAnY2xpY2snKTtcbiAqXG4gKiBjbGlja3NJbkRvY3VtZW50LnN1YnNjcmliZSgoKSA9PiBjb25zb2xlLmxvZygnZG9jdW1lbnQnKSk7XG4gKiBjbGlja3NJbkRpdi5zdWJzY3JpYmUoKCkgPT4gY29uc29sZS5sb2coJ2RpdicpKTtcbiAqXG4gKiAvLyBCeSBkZWZhdWx0IGV2ZW50cyBidWJibGUgVVAgaW4gRE9NIHRyZWUsIHNvIG5vcm1hbGx5XG4gKiAvLyB3aGVuIHdlIHdvdWxkIGNsaWNrIG9uIGRpdiBpbiBkb2N1bWVudFxuICogLy8gXCJkaXZcIiB3b3VsZCBiZSBsb2dnZWQgZmlyc3QgYW5kIHRoZW4gXCJkb2N1bWVudFwiLlxuICogLy8gU2luY2Ugd2Ugc3BlY2lmaWVkIG9wdGlvbmFsIGBjYXB0dXJlYCBvcHRpb24sIGRvY3VtZW50XG4gKiAvLyB3aWxsIGNhdGNoIGV2ZW50IHdoZW4gaXQgZ29lcyBET1dOIERPTSB0cmVlLCBzbyBjb25zb2xlXG4gKiAvLyB3aWxsIGxvZyBcImRvY3VtZW50XCIgYW5kIHRoZW4gXCJkaXZcIi5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGJpbmRDYWxsYmFja31cbiAqIEBzZWUge0BsaW5rIGJpbmROb2RlQ2FsbGJhY2t9XG4gKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICpcbiAqIEBwYXJhbSB7RnJvbUV2ZW50VGFyZ2V0PFQ+fSB0YXJnZXQgVGhlIERPTSBFdmVudFRhcmdldCwgTm9kZS5qc1xuICogRXZlbnRFbWl0dGVyLCBKUXVlcnktbGlrZSBldmVudCB0YXJnZXQsIE5vZGVMaXN0IG9yIEhUTUxDb2xsZWN0aW9uIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlciB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgb2YgaW50ZXJlc3QsIGJlaW5nIGVtaXR0ZWQgYnkgdGhlXG4gKiBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdGhyb3VnaCB0byBhZGRFdmVudExpc3RlbmVyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fVxuICogQG5hbWUgZnJvbUV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXZlbnQ8VD4oXG4gIHRhcmdldDogRnJvbUV2ZW50VGFyZ2V0PFQ+LFxuICBldmVudE5hbWU6IHN0cmluZyxcbiAgb3B0aW9ucz86IEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4gVCksXG4gIHJlc3VsdFNlbGVjdG9yPzogKCguLi5hcmdzOiBhbnlbXSkgPT4gVClcbik6IE9ic2VydmFibGU8VD4ge1xuXG4gIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgLy8gREVQUkVDQVRFRCBQQVRIXG4gICAgcmVzdWx0U2VsZWN0b3IgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgLy8gREVQUkVDQVRFRCBQQVRIXG4gICAgcmV0dXJuIGZyb21FdmVudDxUPih0YXJnZXQsIGV2ZW50TmFtZSwgPEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgdW5kZWZpbmVkPm9wdGlvbnMpLnBpcGUoXG4gICAgICBtYXAoYXJncyA9PiBpc0FycmF5KGFyZ3MpID8gcmVzdWx0U2VsZWN0b3IoLi4uYXJncykgOiByZXN1bHRTZWxlY3RvcihhcmdzKSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlPFQ+KHN1YnNjcmliZXIgPT4ge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoZTogVCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0dXBTdWJzY3JpcHRpb24odGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMgYXMgRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0dXBTdWJzY3JpcHRpb248VD4oc291cmNlT2JqOiBGcm9tRXZlbnRUYXJnZXQ8VD4sIGV2ZW50TmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkLCBzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucz86IEV2ZW50TGlzdGVuZXJPcHRpb25zKSB7XG4gIGxldCB1bnN1YnNjcmliZTogKCkgPT4gdm9pZDtcbiAgaWYgKGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZU9iajtcbiAgICBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHVuc3Vic2NyaWJlID0gKCkgPT4gc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VPYmo7XG4gICAgc291cmNlT2JqLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgdW5zdWJzY3JpYmUgPSAoKSA9PiBzb3VyY2Uub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZU9iajtcbiAgICBzb3VyY2VPYmouYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyIGFzIE5vZGVFdmVudEhhbmRsZXIpO1xuICAgIHVuc3Vic2NyaWJlID0gKCkgPT4gc291cmNlLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciBhcyBOb2RlRXZlbnRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChzb3VyY2VPYmogJiYgKHNvdXJjZU9iaiBhcyBhbnkpLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSAoc291cmNlT2JqIGFzIGFueSkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9ialtpXSwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBldmVudCB0YXJnZXQnKTtcbiAgfVxuXG4gIHN1YnNjcmliZXIuYWRkKHVuc3Vic2NyaWJlKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqOiBhbnkpOiBzb3VyY2VPYmogaXMgTm9kZVN0eWxlRXZlbnRFbWl0dGVyIHtcbiAgcmV0dXJuIHNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLmFkZExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqOiBhbnkpOiBzb3VyY2VPYmogaXMgSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIge1xuICByZXR1cm4gc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmoub24gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5vZmYgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQoc291cmNlT2JqOiBhbnkpOiBzb3VyY2VPYmogaXMgSGFzRXZlbnRUYXJnZXRBZGRSZW1vdmU8YW55PiB7XG4gIHJldHVybiBzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbn1cbiJdfQ==